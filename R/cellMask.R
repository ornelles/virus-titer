#' Voronoi Cell Segmentation from Nuclei
#' 
#' Define boundaries between adjacent cells (regions) from a
#' nuclear mask and optional cellular mask with the
#' \code{\link[EBImage]{propagate}} function. 
#' 
#' @param nmask A segmented nuclear mask such as generated by
#'   \code{nucMask()}.
#' @param cmask An optional \code{Image} object or an array containing a 
#'   binary mask defining regions of the image to be segmented. If this value  
#'   is \code{NULL}, the nuclear mask (\code{nmask}) will be expanded for 
#'   Voronoi segmentation. 
#' @param brush Size of the brush size to expand the nuclear mask as an 
#'   odd number of pixels. If this value is \code{NULL}, the mean value of 
#'   the semi-major axis of all nuclei will be used. 
#' @param lambda A numeric value used by \code{propagate()} determining 
#'   the trade-off between the Euclidean distance in the image plane and the 
#'   contribution of the gradient. See \code{\link[EBImage]{propagate}} for details. 
#'
#' @details
#'
#' A mask to define \emph{approximate} cellular boundaries will be created
#' from a nuclear mask in \code{nmask} and an optional cytoplasmic
#' mask \code{cmask}. If \code{cmask} is \code{NULL}, the nuclear mask will 
#' be dilated with a disc-shaped brush of size equal to \code{brush} or, if
#' \code{brush} is \code{NULL}, the average semi-major axis of all nuclei.
#' If \code{cmask} is not \code{NULL}, \code{cmask} must be a binary mask defining
#' the limits for the Voronoi segmentation based on seeds provided by
#' \code{nmask}. Such a binary mask can be created from a non-specific
#' cytoplasmic stain such as actin or a diffuse membrane stain.
#'
#' To create a cytoplasmic mask that excludes the nucleus, simply subtract
#' the nuclear mask from the cell mask as shown below:
#'
#'   \code{cytoMask <- cellMask(nmask) - nmask}
#'
#' @return
#' 
#' An \code{Image} object produced by \code{propagate()} containing the labeled
#' objects (cells). 
#'
#' @examples
#'   x <- readImage(system.file("extdata", "by_folder/b2/file001.tif", package = "virustiter"))
#'   y <- readImage(system.file("extdata", "by_folder/b2/file002.tif", package = "virustiter"))
#'   nm <- nucMask(x)
#'   cm <- cellMask(nm)
#'   img <- rgbImage(red = normalize(y) * 0.8, green = normalize(y) * 0.2)
#'   img <- paintObjects(nm, img, col = "yellow")
#'   img <- paintObjects(cm, img, col = "green")
#'   plot(img)
#'
#' @import EBImage
#'
#' @export
#'
cellMask <- function(nmask, cmask = NULL, brush = NULL, lambda = 1e-4)
{
# require nmask to be integer mask
	if (!is.integer(imageData(nmask)))
		stop("'", deparse(substitute(nmask)), "' is not an integer Image mask")

# ensure three-dimensions present
	dm <- dim(nmask)
	if (length(dm) == 2)
		dim(nmask) <- c(dm, 1)

# create mask from nmask if cmask == NULL
	if (is.null(cmask)) {
		if (is.null(brush))
			brush <- mean(apply(nmask, 3,
				function(x) mean(computeFeatures.moment(x)[,"m.majoraxis"])))
		brush <- 2*round(brush)%/%2 + 1 # make odd
		cmask <- dilate(nmask, makeBrush(brush, shape = "disc", step = FALSE))
		cmask <- fillHull(cmask)
	}

# ensure that cmask is appropriate
	if (!is.integer(imageData(cmask)))
		stop("'", deparse(substitute(cmask)), "' is not a binary or integer Image mask")
	if (length(dim(cmask)) == 2)
		dim(cmask) <- c(dim(cmask), 1)
	if (!identical(dim(cmask), dim(nmask)))
		stop("dimensions of 'nmask' and 'cmask' are not same")

# restore dimensions and return results from propagate
	dim(nmask) <- dim(cmask) <- dm
	return(propagate(Image(0, dm), seeds = nmask, mask = cmask, lambda = lambda))
}
