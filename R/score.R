#' Score Cells as Positive/Negative
#'
#' Assign \code{logical} variable \code{positive} as TRUE or FALSE in data.frame
#' of fluorescent intensity values based on cutoff values in \code{cut}.
#'
#' @param df A data.frame generated by \code{parseImages()} or
#'   \code{readIJResults()} and appropriate grouping variable.
#' @param cut A numeric vector of length one or a named numeric vector for
#'   each level of the grouping variable \code{well, row, column, or file}. If
#'   missing, the function \code{getCut} will be called with parameters
#'   provided in \code{...} (if any) to determine the cutoff.
#' @param param A character string identifying the variable to be scored.
#' @param ... Additional arguments for \code{getCut()} such as \code{by}.
#'
#' @details
#'
#' A variable named \code{positive} will be added to the data.frame if 
#' necessary and assigned \code{TRUE} or \code{FALSE} if the value 
#' identified as "param" is greater than the appropriate value in
#' \code{cut}. If \code{cut == NULL}, \code{getCut()} will be called
#' with any additional arguments in \code{...} to determine the cutoff.
#'
#' @examples
#' # Small set of data by stack
#'   f <- system.file("extdata", "by_stack/file005.tif", package = "virustiter")
#'   file.copy(f, tempdir(), overwrite = TRUE)
#'   v <- parseImages(tempdir(), pattern = "file005")
#'
#' # Score with grouping value of "file"
#'   v <- score(v, by = "file")
#'   xtabs(~ positive, v)
#'   plot(log(mfi) ~ area, v, col = c(1,2)[positive + 1])
#'
#' @import
#' EBImage
#' genefilter
#'
#' @export
#'
score <- function(df, cut = NULL, param = "mfi", ...)
{
  if (missing(df)) {
    usage <- c("score examples:",
      '  score(df, cut)         ## cut holds cutoff values',
      '  score(df, 123)         ## single value used as cutoff')
    cat(usage, sep = "\n")
    return(invisible(NULL))
  }
  stopifnot(param %in% names(df))
  if (is.null(cut)) {
    message("using default parameters in getCut() for 'cut' parameter")
    cut <- getCut(df, param = param, ...)
  }

  if (length(cut) == 1)     # single values
    df$positive <- df[[param]] > cut
  else if (all(names(cut) %in% levels(df$well)))
    df$positive <- df[[param]] > cut[df$well]
  else if (all(names(cut) %in% levels(df$row)))
    df$positive <- df[[param]] > cut[df$row]
  else if (all(names(cut) %in% levels(df$column)))
    df$positive <- df[[param]] > cut[df$column]
  else if (all(names(cut) %in% levels(df$file)))
    df$positive <- df[[param]] > cut[df$file]
  else
    stop("cut must be a single value or a named vector (file, well, row, or column)")
  return(df)
}
