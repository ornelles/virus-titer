#' Score Cells as Positive/Negative
#'
#' Assign \code{logical} variable \code{positive} as TRUE or FALSE in data.frame
#' of fluorescent intensity values based on cutoff values in \code{cut}.
#'
#' @param df A data.frame generated by \code{parseImages()} or
#'   \code{readIJResults()} and appropriate grouping variable.
#' @param cut A numeric vector of length one or a named numeric vector for
#'   each level of the grouping variable, typically \code{well, row, column, or file}.
#'   If missing, the function \code{getCut} will be called with parameters
#'   provided in \code{...} (if any) to determine the cutoff.
#' @param param A character string identifying the variable to be scored.
#' @param ... Additional arguments for \code{getCut()} such as \code{by}.
#'
#' @details
#'
#' A variable named \code{positive} will be added to the data.frame if 
#' necessary and assigned \code{TRUE} or \code{FALSE} if the value 
#' identified as "param" is greater than the appropriate value in
#' \code{cut}. If \code{cut == NULL}, \code{getCut()} will be called
#' with any additional arguments in \code{...} to determine the cutoff.
#'
#' @examples
#' # Small set of data by stack
#'   f <- system.file("extdata", "by_stack/file005.tif", package = "virustiter")
#'   file.copy(f, tempdir(), overwrite = TRUE)
#'   v <- parseImages(tempdir(), pattern = "file005")
#'
#' # Score with grouping value of "file"
#'   v <- score(v, by = "file")
#'   xtabs(~ positive, v)
#'   plot(log(mfi) ~ area, v, col = c(1,2)[positive + 1])
#'
#' @import
#' EBImage
#' genefilter
#'
#' @export
#'
score <- function(df, cut = NULL, param = "mfi", ...)
{
  if (missing(df)) {
    usage <- c("score examples:",
      '  score(df, cut)         ## cut holds cutoff values',
      '  score(df, 123)         ## single value used as cutoff')
    cat(usage, sep = "\n")
    return(invisible(NULL))
  }
  stopifnot(param %in% names(df))
  if (is.null(cut)) {
    message("using default parameters in getCut() for 'cut' parameter")
    cut <- getCut(df, param = param, ...)
  }

  if (length(cut) == 1)     # single values
    df$positive <- df[[param]] > cut
	else {	# search for names of cut among factors in df
		choices <- lapply(df[sapply(df, is.factor)], levels)
		sel <- sapply(choices, function(v) all(names(cut) %in% v))
		if (sum(sel) > 1)
			stop("found ", sum(sel), " possible factors matching 'cut' in 'df'")
		else if (sum(sel) == 0)
			stop("'cut' must be a single value or a named vector matching a factor in 'df'")
		else {
			g <- names(which(sel))
			df$positive <- df[[param]] > cut[df[[g]]]
		}
	}
  return(df)
}
