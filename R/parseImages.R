#' Read Values from DNA and Fluorescent Microscopic Images
#'
#' Read DNA and fluorescent images organized as paired images. Return mean
#' fluorescence intensity values for DNA and related fluorescent image.
#'
#' @param path Character vector of directory with either multilayer tiff
#'   image files \emph{or} subdirectories identified by well with separate,
#'   paired images per well.
#' @param type Character string of image files as "tif", "tiff", "jpeg", "jpg" or "png".
#' @param which.images Integer of length 2 or 3. The first two numbers specify
#'   the relative position of the DNA image and the target image. The optional
#'   third number specifies the total images for each field. A value of c(1, 2)
#'   indicates DNA first and target second. A value of c(2, 1) indicates that
#'   the order is target first and DNA image second. A value of c(1, 2, 3)
#'   indicates DNA, target, and a third (ignored) image such as phase contrast
#'   in each set.
#' @param pattern Optional grep pattern as character string to select image files
#' @param args.nucMask A list of arguments that are to replace any default
#' arguments in \code{nucMask()}.
#' @param args.trimMask A list of arguments that are to replace any default
#'    arguments in \code{trimMask()}. If this value is \code{NA}, no trimming
#'    is performed.
#' @param cellMask.flag If this \code{logical} value is \code{TRUE}, the default
#'   nuclear mask will be replaced with a mask generated by \code{cellMask()}
#'   and used to measure fluorescent intensity in the target image.
#'
#' @details
#'
#' This is the core function to read and parse image data in a suite of tools
#' implemented with \code{\link{EBImage}} that has been developed to determine
#' viral titers from fluorescent micrograph pairs, where the first of each pair
#' is an (ideally overexposed) DNA image and the second a fluorescent image
#' represents the target or viral signal.
#'
#' This function was developed to process fluorescent virus titers
#' performed in multi-well plates and is designed to parse pairs of images
#' collected at different multiplicities of infection or moi. This
#' information (moi) is expressed as virions (VP) \emph{or} infectious
#' units (IU) \emph{or} volume (ml, ul, nl) per cell and is added to the
#' data generated with this funciton with the \code{mergePdata()} function.
#' The nuclear (typically DAPI) image file is expected to precede the
#' corresponding viral antigen image file but this order can be changed with
#' the \code{which.images} argument.
#'
#' Pairs of images associated with each moi can be individual files in a
#' single directory where each directory is named for the well such as a1,
#' a2, etc. and the files within are identified as
#' \code{a1/file001.tif}, \code{a1/file002.tif}, etc. The well can be either upper
#' or lower case and can contain leading zeros.
#'
#' Alternatively, each group of images associated with a given moi can be
#' a multi-layered tiff file where the sequence of images is
#' specified by the argument \code{which.images}.
#'
#' @return
#'
#' A data.frame of processed image data. All data.frames will have the
#' following variables:
#' \describe{
#'   \item{\code{directory}}{Path to enclosing folder.}
#'   \item{\code{frame}}{Image sequence (1, 2, 3, ...)}
#'   \item{\code{xm, ym}}{Center of mass (in pixels) for nucleus.}
#'   \item{\code{area}}{Area of mask (nuclear or cell).}
#'   \item{\code{dna}}{Mean fluorescence intensity for DNA stain,
#'     typically not meaningful with over-exposed images.}
#'   \item{\code{mfi}}{Mean fluorescence intensity for signal of interest,
#'     measured in given mask.}
#' }
#' Results from data organized by well will include \code{well}, \code{row}
#' and \code{column} values as factors.
#'
#' Results from data organized as stacks (multi-layered tiff files) will
#' include the filename in \code{file} as a factor.
#'
#' @examples
#' #
#' # Note that execution of these examples can be rather slow...
#' #
#'   path.by.folder <- system.file("extdata", "by_folder", package = "virustiter")
#'   df.by.folder <- parseImages(path.by.folder)
#'   head(df.by.folder)[-1] # drop potentially log directory name
#'
#'   path.by.stack <- system.file("extdata", "by_stack", package = "virustiter")
#'   df.by.stack <- parseImages(path.by.stack)
#'   head(df.by.stack)[-1] # drop potentially log directory name
#' #
#' # plot
#' #
#'   opar <- par(mfrow = c(1,2))
#'   plot(log(mfi) ~ area, df.by.folder, main = "By Folder", las = 1)
#'   plot(log(mfi) ~ area, df.by.stack, main = "By Stack", las = 1)
#'   par(opar)
#'
#' @import EBImage
#'
#' @export
#'
parseImages <- function(path, type = "tiff", which.images = c(1, 2, 2),
	pattern = NULL, args.nucMask = NULL, args.trimMask = NULL,
	cellMask.flag = FALSE)
{
# requires EBImage, ensure appropriate values for parameters
	if (!require(EBImage))
		stop("The 'EBImage' package must be installed with biocLite")
	if (length(path) > 1)
		warning("only the first value in 'path' will be used")
	path <- path[1]
	if (file.info(path)$isdir == FALSE)
		stop("The value in 'path' is not a directory.")
	if (length(which.images) == 2)
			which.images <- c(which.images, max(which.images))
	if (length(which.images) != 3)
		stop("'which.images' must be an integer vector of length 2 or 3")
	if (which.images[3] != max(which.images))
		stop("the third value in 'which.images' must be the largest")

# extract paths to image files
	ff <- list.images(path = path, type = type, pattern = pattern)

# extract fields to determine if images are organized by well or stack
	spl <- strsplit(ff, "/")
	field1 <- sapply(spl, tail, 1)
	field2 <- sapply(spl, function(x) head(tail(x, 2), 1))
	sel <- grepl("^[[:alpha:]][[:digit:]]+$", field2) # test for well pattern

# assign variables to direct processing
	if (all(sel)) {
		imageType <- "byWell"
		well <- field2
		filename <- NULL
	}
	else if (!any(sel)) {
		imageType <- "byStack"
		well <- NULL
		filename <- field1
	}
	else
		stop("unable to use mixture of image files in ", path, '"')

# split image paths into related groups (by well or by file)
	if (imageType == "byWell")
		ffsplit <- split(ff, well)
	else if (imageType == "byStack")
		ffsplit <- split(ff, filename)
	else
		stop("unexpected value for 'imageType'")

# read all images as a list and coerce to grayscale with a warning
	img <- lapply(ffsplit, function(f) suppressWarnings(readImage(f)))
	if (any(sapply(img, colorMode) != 0)) {
		warning("images have been converted to grayscale by uniform RGB averaging")
		img <- lapply(img, channel, "gray")
	}

# check for expected numbers of images
	n_dna <- which.images[1]
	n_mfi <- which.images[2]
	n_field <- which.images[3]

# are total images in each group sensible?
	n <- sapply(img, function(x) dim(x)[3])
	bad <- which(n %% n_field != 0)
	if (length(bad))
		stop("The number of images in ", paste(names(img)[bad], collapse = ", "),
			" are not multiples of ", n_field)

# extract dna images
	dnaImages <- lapply(img, function(x, first = n_dna, by = n_field) {
		N <- dim(x)[3]
		x[,,seq(first, N, by)]})

# extract mfi images
	mfiImages <- lapply(img, function(x, first = n_mfi, by = n_field) {
		N <- dim(x)[3]
		x[,,seq(first, N, by)]})

# initialize variable to collect results, initialize progress bar
	nff <- length(ffsplit)
	ret <- rep(list(NULL), nff)
	showProgress <- ifelse(nff > 2, TRUE, FALSE)

	if (showProgress)
		pb <- txtProgressBar(min = 1, max = nff, style = 3)

# process each group of files in turn
	for (idx in seq_along(ffsplit)) {
		if (showProgress)
			setTxtProgressBar(pb, idx)

	# create mask with any additional arguments in args.nucMask
		arg.list <- as.list(args(nucMask))
		arg.list <- arg.list[names(arg.list) != ""] # drop NULL values
		arg.list$dna <- dnaImages[[idx]]
		nms <- names(args.nucMask)
		nms <- nms[nms %in% names(arg.list)] # find replacements
		sel <- names(arg.list) %in% nms
		arg.list <- c(arg.list[!sel], args.nucMask[nms])
		nmask <- do.call(nucMask, arg.list)

	# remove small and large nuclei with arguments in args.trimMask
		if (is.null(args.trimMask) || (!is.na(args.trimMask))) {
			arg.list <- as.list(args(trimMask))
			arg.list <- arg.list[names(arg.list) != ""]
			arg.list$mask <- nmask
			nms <- names(args.trimMask)
			nms <- nms[nms %in% names(arg.list)]
			sel <- names(arg.list) %in% nms
			arg.list <- c(arg.list[!sel], args.trimMask[nms])
			nmask <- do.call(trimMask, arg.list)
		}

	# expand mask to use estimated cell
		if (cellMask.flag == TRUE)
			cmask <- cellMask(nmask)
		else
			cmask <- nmask

	# measure and assemble data for the group indexed by 'idx'
		nframes <- dim(nmask)[3]
		res <- data.frame()
		for (i in seq_len(nframes)) {
			area <- computeFeatures.shape(cmask[,,i])[,1]
			XY <- computeFeatures.moment(nmask[,,i])[,1:2]
			dna <- computeFeatures.basic(nmask[,,i], dnaImages[[idx]][,,i])[,1]
			mfi <- computeFeatures.basic(cmask[,,i], mfiImages[[idx]][,,i])[,1]
			if (imageType == "byWell") {
				ww <- names(ffsplit)[idx]
				res <- rbind(res, data.frame(directory = paste(path, ww, sep = "/"),
					well = well.info(ww)$well, row = well.info(ww)$row,
					column = well.info(ww)$column, frame = i,
					xm = XY[,1], ym = XY[,2], area, dna, mfi))
			}
			else # imageType == "byStack"
				res <- rbind(res, data.frame(directory = path,
					file = names(ffsplit)[idx], frame = i, xm = XY[,1], ym = XY[,2],
					area, dna, mfi))
		}
		rownames(res) <- NULL
		ret[[idx]] <- res
	}

# compile and return collected data
	ans <- do.call(rbind, ret)
	rownames(ans) <- NULL
	if (showProgress)
		close(pb)
	return(ans)
}
