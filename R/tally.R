#' Tally Positive Fluorescent Values
#'
#' Tally positive and negative values from from data.frame generated
#' by \code{parseImages()} by either "well" or "file" representing each
#' value of multiplicity.
#'
#' @param df Annotated \code{data.frame} with fluorescent values to evaluate.
#' @param moi Character string identifying the independent value. If missing,
#'   variables named \code{"moi"} and \code{"x"} will be sought and used. Note
#'   that in the returned value, this variable will be named \code{"x"}.
#' @param param Variable name as character string in \code{df} to evaluate, 
#'   typically \code{"mfi"}.
#' @param pd Optional phenotype \code{data.frame} to add to results.
#'
#' @details
#'
#' The variable named \code{positive} will be tallied for each level of
#' "file" or "well" in the argument \code{df}. The dependent variable can
#' be specified by the \code{moi} argument. 
#'
#' @return
#'
#' A \code{data.frame} of tallied values for each level of the grouping
#' variable (\code{well} or \code{file}) with possibly additional information
#' after merging phenotype data. Variables generated by \code{tally} are
#' expected by downstream functions. Notably, the dependent variable will
#' be renamed \code{x} in the output. These variables include:
#' \itemize{
#' 	\item The independent variable representing the multiplicity of infection
#'     in \code{x}
#'   \item The dependent variable as the fraction of positive cells in \code{y}
#'   \item The number of positive cells in \code{pos}
#'   \item The number of negative in \code{neg}
#'   \item Details about the grouping variable, either \code{well} or \code{file}
#' }
#'
#' @examples
#' # Sample data by folder
#'   f <- system.file("extdata", "by_folder", package = "virustiter")
#'   pd <- read.csv(system.file("extdata", "by_folder/phenoData.csv", package = "virustiter"))
#'   v <- parseImages(f)
#'   v <- mergePdata(pd, v)
#'   v <- score(v)
#'   tally(v)
#'
#' @import
#' EBImage
#' genefilter
#'
#' @export
#'  
tally <- function(df, moi, param = "mfi", pd = NULL)
{
	if(!"positive" %in% names(df))
		stop("\ntally() requires the logical variable 'positive'.",
			"\nPerhaps score() needs to be called on '", deparse(substitute(df)),
			"' first?")
	if (!param %in% names(df))
		stop("'", deparse(substitute(param)), "' is missing from 'df'")

# determine if the value for moi is present or seek "moi" or "x"
	if (missing(moi)) {
		if ("moi" %in% names(df))
			moi <- "moi"
		else if ("x" %in% names(df))
			moi <- "x"
		else
			stop('A variable named "moi" or "x" must be present in ',
				"'", deparse(substitute(df)), "'", " if not provided for 'moi'")
	}
	else if (!moi %in% names(df))
		stop("'", deparse(substitute(df)), "' does not have a variable named ",
			deparse(substitute(moi)))

# assign grouping variable
	if (all(c("well", "file") %in% names(df)))
		stop("'df' must have EITHER a factor named 'well' OR a factor named 'file'")
	if ("well" %in% names(df))
		by = "well"
	else if("file" %in% names(df))
		by = "file"
	else
		stop("'df' must have a factor variable named 'well' or 'file'")
	group <- df[[by]]

# extract data frame name
	if (by == "well")
		dir <- dirname(levels(df$directory))[1]
	else
		dir <- levels(df$directory)[1]
	if (is.null(dir))
		dir <- "unknown"

# record unit of measure
	unit <- df$unit[1]
	if (is.null(unit))
		unit <- "unknown"

# tally positive and create results data.frame
	pos <- tapply(df$positive == TRUE, group, sum)
	neg <- tapply(df$positive == FALSE, group, sum)
	y <- pos/(pos + neg)
	x <- sapply(names(pos), function(v) df[[moi]][group == v][1])
	if (by == "well") {
		well <- names(pos)
		row <- well.info(well)$row
		column <- well.info(well)$column
		res <- data.frame(dir, well, row, column, unit, pos, neg, x, y)
	}
	else if (by == "file") {
		res <- data.frame(dir, file = names(pos), unit, pos, neg, x, y)
	}
	else 
		res <- data.frame(dir, group = names(pos), unit, pos, neg, x, y)
	if (!is.null(pd))
		res <- mergePdata(pd, res)
	rownames(res) <- NULL
	return(res)
}
