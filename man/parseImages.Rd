% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parseImages.R
\name{parseImages}
\alias{parseImages}
\title{Parse Paired Microscopic Images}
\usage{
parseImages(nuc, tgt = NULL, nMask = NULL, cMask = FALSE,
  args.nMask = NULL, args.trimMask = NULL, args.cMask = NULL,
  equalize = FALSE, simplify = TRUE)
}
\arguments{
\item{nuc}{A list of nuclear images, \emph{or}, if the second argument
(\code{tgt}) is \code{NULL}, a list of length 2 containing nuclear and
target images.}

\item{tgt}{A list of fluorescent images corresponding to the nuclear images
in \code{nuc}. If this argument is \code{NULL}, \code{nuc} must be a
list of both image types.}

\item{nMask}{An optional \code{Image} object, array, or a \code{list}
these objects containing an integer \code{Image} mask identifying nuclei.
If this value is \code{NULL}, the nuclear mask will be determined by
\code{nucMask()} with any arguments provided in \code{args.nMask}.}

\item{cMask}{An optional \code{Image} object, array, or a \code{list}
these objects containing an integer \code{Image} mask defining the
region of the image to define cell boundaries. If \code{TRUE}, the
nuclear mask will be used to generate a mask with \code{cellMask()}.
This larger mask will be used to measure fluorescence intensity in the
target image.}

\item{args.nMask}{A list of arguments passed to \code{\link{nucMask()}}.
This argument is ignored if a \code{nMask} is provided.}

\item{args.trimMask}{A list of arguments passed to \code{\link{trimMask()}}.
This argument is ignored if a \code{nMask} is provided. Otherwise, if
\code{NULL}, \code{trimMask()} will be called with default parameters.
If \code{FALSE}, no trimming will be performed.}

\item{equalize}{If the fluorescent target images have \emph{more background
pixels than foreground pixels} and if the background varies significantly
from image to image, this can be set to \code{TRUE} in order to equalized
the fluorescent images by subtracting the median value after applying a
median filter and gaussian blur using the function \code{bnormalize()}.}

\item{simplify}{Return a single \code{data.frame} of results if \code{TRUE},
otherwise return a list of \code{data.frames} for each member of the list.}
}
\value{
A data.frame (or list of data.frames) containing  processed image
data. \strong{Each} data.frame will have the following variables:
\describe{
  \item{\code{frame}}{Image sequence within each level of well
    or file as a factor (f001, f002, f003, ...)}
  \item{\code{xm, ym}}{Center of mass (in pixels) for nucleus.}
  \item{\code{area}}{Area of the mask (in pixels) used to calculate target mfi.}
  \item{\code{dna}}{Mean fluorescence intensity for DNA stain,
    typically not meaningful if the DNA image was over-exposed.}
  \item{\code{mfi}}{Mean fluorescence intensity for the target,
    measured with selected mask.}
}
Results from data organized by \strong{well} will also include:
\describe{
  \item{\code{well}}{Harmonized well identifier from the \code{well.info()} function.}
  \item{\code{row}}{Row identifier ("A", "B", "C", etc.) as a factor.}
  \item{\code{column}}{Column number as a factor.}
}
Results from data organized as multi-layered tiff files (or stacks)
will include:
\describe{
  \item{\code{file}}{The file name as a factor.}
}
}
\description{
Identify nuclei by a DNA stain and measure the fluorescence intensity of
the DNA and a second second fluorescent target image from paired images.
}
\details{
This function identifies cells by a DNA stain and measures the
fluorescent intensity in both the DNA image and the paired fluorescent image.
This is part of a suite of tools implemented with \code{\link{EBImage}}
designed to determine viral titers from sets of fluorescent micrographs.
The first argument to this function can be the result of the function
\code{\link{getImages()}}. Images provided to this function are pairs where
the first of each pair is a DNA image and the second is a fluorescent image
of the viral antigen. Because individual cells are identified by the nuclear
stain, it is often beneficial to collect overexposed DNA images.

These tools were developed to process fluorescent virus titers
performed in multi-well plates and is designed to parse images
collected at different multiplicities of infection or moi. The
moi can be expressed as virions (VP) per cell \emph{or} infectious
units (IU) per cell \emph{or} a unit of volume (ml, ul, nl) per cell.
These details are added to output of this function with the
\code{mergePdata()} function. Images must be orderws with the nuclear
(typically DAPI) image before the viral antigen image. Note that this
sequence can be adjusted with \code{which.images} argument in
the function \code{\link{getImages()}}.

Images associated with each moi can be individual files in a
single directory where each directory is named for the well such as
\code{A1}, \code{A2}, etc. and the files within are identified as
\code{A1/file001.tif}, \code{A1/file002.tif}, etc. The well identifier
can be in upper or lower case and can contain leading zeros such as
\code{c0003/file12.tif}.

Alternatively, each group of images associated with a given moi can be
a multi-layered tiff file where the sequence of images in the file is
specified by the argument \code{which.images}.

A unique ID for each image can be created from a combination of
\code{frame} and either \code{well} or \code{file}. This can be useful
if it is necessary to determine a separate background value for each
pair of images.
\preformatted{
  df$uid <- with(df, interaction(well, frame))
  df$uid <- with(df, interaction(file, frame))
}

If the images have background values that vary from image to image or
have significant noise and if the fluorescent images have \emph{more}
background pixels than foreground pixels, then the argument
\code{equalize} can be set to \code{TRUE}. This smooths the images by
sequentially modifying values in each target image with a
median filter of radius 2, a Gaussian blur of radius 2, subtracting
the median value for each image and adding an offset of 0.05.
\emph{This cannot be used for images that have a large fraction
of positive cells, such as the example data set.}
}
\examples{
# Note that execution of these examples can be rather slow...
  path.by.folder <- system.file("extdata", "by_folder", package = "virustiter")
  images.by.folder <- getImages(path.by.folder)
  df.by.folder <- parseImages(images.by.folder)
  head(df.by.folder)

  path.by.stack <- system.file("extdata", "by_stack", package = "virustiter")
  images.by.stack <- getImages(path.by.stack)
  df.by.stack <- parseImages(images.by.stack)
  head(df.by.stack)

# plots
  opar <- par(mfrow = c(1,2))
  plot(log(mfi) ~ area, df.by.folder, main = "By Folder", las = 1)
  plot(log(mfi) ~ area, df.by.stack, main = "By Stack", las = 1)
  par(opar)

}
